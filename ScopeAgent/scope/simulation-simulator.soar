# indicate that we are simulating the simulator
sp {simulator*indicator
   (state <s> ^io.input-link <input>)
   (<input> -^IMPRINT)
-->
   (<s> ^simulated yes)
}

# test choosing ignore-new over interrupt-task
# get the first one out of the way
sp {start*simulation*simulator
   (state <s> ^operator <o>
              ^simulated yes
              ^io.input-link <input>)
   (<o> ^name initialize-scope)
-->
   (<s> ^phase simulate-input)
   (<input> ^threshold 8)
}

# alternate a simulated input
sp {propose*simulate-input
   (state <s> ^name scope
              ^phase simulate-input
              ^simulated yes)
-->
   (<s> ^operator <o> + !)
   (<o> ^name simulate-input)
}
# in the application of input simulation,
# change phase back to real scope processing
sp {apply*simulate-input
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes)
   (<o> ^name simulate-input)
-->
   (<s> ^phase simulate-input -)
}
# in the application of real scope processing,
# change phase back to input simulation
sp {apply*not-simulate-input
   (state <s> ^name scope
              ^operator <o>
              ^simulated yes)
   (<o> -^name simulate-input
         ^strategy yes)
-->
   (<s> ^phase simulate-input)
}
              
# test choosing perform-all
sp {perform-all-test-init
   (state <s> ^disable
              ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<input> ^over-threshold no
            ^task <t1> <t2>)
}

# elaborate operators to indicate that they are strategy operators
# TODO this should not be defined here because it's used in real operation
sp {elaborate*strategy*operators
   (state <s> ^operator <o> +)
   (<o> ^name << perform-all ignore-new interrupt-task delay-new >> )
-->
   (<o> ^strategy yes)
}


# initialize strategy counter
# TODO this can't test ^simulated because real rules test ^strategy-counter
sp {apply*initialize-strategy-counter
   (state <s> ^operator <o>
)#              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<s> ^strategy-counter 0)
}
# TODO you have to test ^strategy-counter in the
# conditions for every strategy operator proposal or this
# elaborates infinitely. figure out why
# increment a counter every time a strategy decision is made
sp {apply*increment-strategy-counter
   (state <s> ^name scope
              ^operator <o>
              ^strategy-counter <count>
              ^simulated yes)
    (<o> ^strategy yes)
-->
   (<s> ^strategy-counter (+ <count> 1)
        ^strategy-counter <count> -)
}

# simulator effects for output commands
# TODO
sp {apply*perform-all*effects
   (state <s> ^disable
              ^name scope
              ^operator <o>
              ^io.input-link.task <task>)
   (<o> ^name perform-all)
   (<task> ^release yes)
-->
   (<task> ^release yes -)
}

# set which test we want to perform
sp {init*task*events
   (state <s> ^operator <o>
              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<o> ^test-name simultaneous-add-remove)
}
sp {init*default
   (state <s> ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope
        ^test-name default)
-->
   (<s> ^simulate-task <n1>)
   (<n1> ^task <t1>)
   (<t1> ^workload 4
         ^ID 0
         ^release yes)
   (<n1> ^next <n2>)
   (<n2> ^remove <r1>)
   (<r1> ^obj <t1>
         ^attribute release
         ^value yes)
   (<n2> ^task <t2>)
   (<t2> ^workload 4
         ^ID 1
         ^release yes)
   (<n2> ^next <n3>)
   (<n3> ^remove <r2>)
   (<r2> ^obj <t2>
         ^attribute release
         ^value yes)
   (<n3> ^task <t3>)
   (<t3> ^workload 4
         ^ID 3
         ^release yes)
   (<n3> ^next <end>)
}

sp {initialize*simultaneous*add*remove
   (state <s> ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope
        ^test-name simultaneous-add-remove)
-->
   (<s> ^simulate-task <n1>)
   # t=1 add the first task
   (<n1> ^add <a1>)
   (<a1> ^obj <input>
         ^task <t1>)
   (<t1> ^workload 3
         ^ID 0
         ^release yes)
   (<n1> ^next <n2>)
   # t=2 add the second task
   (<n2> ^add <a2>)
   (<a2> ^obj <input>
         ^task <t2>)
   (<t2> ^workload 2
         ^ID 1
         ^release yes)
   # t=2 remove release state of first task
   (<n2> ^remove <r2>)
   (<r2> ^obj <t1>
         ^attribute release
         ^value yes)
   (<n2> ^next <n3>)
   # t=2 add active state to first task
   (<n2> ^add <a2-2>)
   (<a2-2> ^obj <t1>
           ^active yes)
   # t=3 remove the first task
   (<n3> ^remove <r3>)
   (<r3> ^obj <input>
         ^attribute task
         ^value <t1>)
   # t=3 remove release state of second task
   (<n3> ^remove <r3-2>)
   (<r3-2> ^obj <t2>
         ^attribute release
         ^value yes)
   # t=3 add active state to second task
   (<n3> ^add <a3>)
   (<a3> ^obj <t2>
         ^active yes)
   # t=3 also add a brand new task
   (<n3> ^add <a3>)
   (<a3> ^obj <input>
         ^task <t3>)
   (<t3> ^workload 1
         ^ID 2
         ^release yes)
   # add one more event so it doesn't kill it too early
   (<n3> ^next <n4>)
}

# generalized rules
sp {apply*simulate-input*remove
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task <event>)
   (<o> ^name simulate-input)
   (<event> ^remove <removal>)
   (<removal> ^obj <obj>
              ^attribute <attr>
              ^value <val>)
-->
   (<obj> ^<attr> <val> -)
}
sp {apply*simulate-input*add
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task <event>)
   (<o> ^name simulate-input)
   (<event> ^add <addition>)
   (<addition> ^obj <obj>
               ^{<attr> <> obj} <val>)
-->
   (<obj> ^<attr> <val>)
}
sp {apply*simulate-input*add*task
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task <event>
              ^io.input-link <input>)
   (<o> ^name simulate-input)
   (<event> ^task <task>)
-->
   (<input> ^task <task>)
}
sp {apply*simulate-input*end
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task <event>)
   (<event> -^next <next>)
-->
   (write (crlf) |end|)
   (halt)
}
sp {x*finish*simulate*input
   (state <s> ^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulate-task <event>)
   (<event> ^next <next>)
   (<o> ^name simulate-input)
-->
   (<s> ^simulate-task <event> -
        ^simulate-task <next>)
}