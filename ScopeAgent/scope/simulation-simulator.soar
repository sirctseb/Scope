# indicate that we are simulating the simulator
sp {simulator*indicator
   (state <s> ^io.input-link <input>)
   (<input> -^IMPRINT)
-->
   (<s> ^simulated yes)
}

# test choosing ignore-new over interrupt-task
# get the first one out of the way
sp {start*simulation*simulator
   (state <s> ^operator <o>
              ^simulated yes
              ^io.input-link <input>)
   (<o> ^name initialize-scope)
-->
   (<s> ^phase simulate-input)
   (<input> ^threshold 8)
}

# alternate a simulated input
sp {propose*simulate-input
   (state <s> ^name scope
              ^phase simulate-input
              ^simulated yes)
-->
   (<s> ^operator <o> + !)
   (<o> ^name simulate-input)
}
# in the application of input simulation,
# change phase back to real scope processing
sp {apply*simulate-input
   (state <s> ^name scope
              #^phase simulate-input
              ^operator <o>
              ^simulated yes)
   (<o> ^name simulate-input)
-->
   (<s> ^phase simulate-input -)
}
# in the application of real scope processing,
# change phase back to input simulation
sp {apply*not-simulate-input
   (state <s> #^name scope
              ^operator <o>
              ^simulated yes
              ^top-state <ts>)
   (<o> -^name simulate-input
         ^strategy yes)
-->
   (<ts> ^phase simulate-input)
}
              
# test choosing perform-all
sp {perform-all-test-init
   (state <s> ^disable
              ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<input> ^over-threshold no
            ^task <t1> <t2>)
}

# elaborate operators to indicate that they are strategy operators
# TODO this should not be defined here because it's used in real operation
sp {elaborate*strategy*operators
   (state <s> ^operator <o> +)
   (<o> ^name << perform-all ignore-new interrupt-task delay-new >> )
-->
   (<o> ^strategy yes)
}


# initialize strategy counter
# TODO this can't test ^simulated because real rules test ^strategy-counter
sp {apply*initialize-strategy-counter
   (state <s> ^operator <o>
)#              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<s> ^strategy-counter 0)
}
# TODO you have to test ^strategy-counter in the
# conditions for every strategy operator proposal or this
# elaborates infinitely. figure out why
# increment a counter every time a strategy decision is made
sp {apply*increment-strategy-counter
   (state <s> #^name scope
              ^operator <o>
              ^strategy-counter <count>
              ^simulated yes)
    (<o> ^strategy yes)
-->
   (<s> ^strategy-counter (+ <count> 1)
        ^strategy-counter <count> -)
}

# remove old commands from output
sp {apply*remove*old*commands
   (state <s> ^simulated yes
              ^operator <o>
              ^io.output-link <output>)
   (<output> ^strategy <strategy>)
   (<strategy> ^complete yes)
   (<o> ^name simulate-input)
-->
   (<output> ^strategy <strategy> -)
}
# simulator effects for output commands
sp {apply*perform-all*effects
   (state <s> ^simulated yes
              ^operator <o>
              ^io.input-link.task <task>
              ^io.output-link.strategy <strategy>)
   (<strategy> ^name perform-all
              -^complete yes)
   (<o> ^name simulate-input)
   (<task> ^release yes)
-->
   # remove release flag
   (<task> ^release yes -)
   # add active flag
   (<task> ^active yes)
   # mark as complete
   (<strategy> ^complete yes)
}

sp {apply*ignore-new*effects
   (state <s> ^simulated yes
              ^operator <o>
              ^io.input-link <input>
              ^io.input-link.task <task>
              ^io.output-link.strategy <strategy>)
   (<strategy> ^name ignore-new
              -^complete yes)
   (<o> ^name simulate-input)
   (<task> ^release yes)
-->
   # remove task from input
   (<input> ^task <task> -)
   # mark as complete
   (<strategy> ^complete yes)
}

sp {apply*interrupt-task*effects
   (state <s> ^simulated yes
              ^operator <o>
              ^io.input-link <input>
              ^io.input-link.task <interrupt-task>
              ^io.input-link.task <new-task>
              ^io.output-link.strategy <strategy>)
   (<o> ^name simulate-input)
   (<strategy> ^name interrupt-task
         ^interrupt-task <interrupt-task>
         ^new-task <new-task>
        -^complete yes)
-->
   # remove release flag from new task
   (<new-task> ^release yes -)
   # add active flag to new task
   (<new-task> ^active yes)
   # remove interrupted task from input
   # TODO this would be easier if it was just flagged
   # and left there.
   # TODO simulate attempts to resume interrupted task
   (<input> ^task <interrupt-task> -)
   # store task in special place on top state
   # so that we many resume it some time
   (<s> ^interrupted-task <interrupt-task>)
   # mark as complete
   (<strategy> ^complete yes)
}

# set which test we want to perform
sp {init*task*events
   (state <s> ^operator <o> +
              ^simulated yes)
   (<o> ^name initialize-scope)
-->
   (<o> ^test-name tie*interrupt*delay*ignore)
}

# copy down simulation commands into substates
sp {copy*simulation*state
   (state <s> ^superstate.simulate-task <st>)
-->
   (<s> ^simulate-task <st>)
}
sp {init*default
   (state <s> ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope
        ^test-name default)
-->
   (<s> ^simulate-task <sim>)
   (<sim> ^current <n1>)
   # t=1 add initial task with ^release
   (<n1> ^task <t1>)
   (<t1> ^workload 4
         ^ID 0
         ^release yes)
   (<n1> ^next <n2>)
   # t=2 add second task with ^release
   (<n2> ^task <t2>)
   (<t2> ^workload 4
         ^ID 1
         ^release yes)
   (<n2> ^next <n3>)
   # t=3 add third task
   (<n3> ^task <t3>)
   (<t3> ^workload 4
         ^ID 3
         ^release yes)
   # add one more event
   (<n3> ^next <end>)
}

sp {initialize*simultaneous*add*remove
   (state <s> ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope
        ^test-name simultaneous-add-remove)
-->
   (<s> ^simulate-task <sim>)
   (<sim> ^current <n1>)
   # t=1 add the first task
   (<n1> ^add <a1>)
   (<a1> ^obj <input>
         ^task <t1>)
   (<t1> ^workload 3
         ^ID 0
         ^release yes)
   (<n1> ^next <n2>)
   # t=2 add the second task
   (<n2> ^add <a2>)
   (<a2> ^obj <input>
         ^task <t2>)
   (<t2> ^workload 2
         ^ID 1
         ^release yes)
   (<n2> ^next <n3>))
   # t=3 remove the first task
   (<n3> ^remove <r3>)
   (<r3> ^obj <input>
         ^attribute task
         ^value <t1>)
   # t=3 also add a brand new task
   (<n3> ^add <a3>)
   (<a3> ^obj <input>
         ^task <t3>)
   (<t3> ^workload 1
         ^ID 2
         ^release yes)
   # add one more event so it doesn't kill it too early
   (<n3> ^next <n4>)
}
sp {initialize*tie*interrupt*delay*ignore
   (state <s> ^operator <o>
              ^io.input-link <input>
              ^simulated yes)
   (<o> ^name initialize-scope
        ^test-name tie*interrupt*delay*ignore)
-->
   (<s> ^simulate-task <sim>)
   (<sim> ^current <n1>)
   # t=1 add first task
   (<n1> ^add <a1>)
   (<a1> ^obj <input>
         ^task <t1>)
   (<t1> ^ID 0
         ^workload 5
         ^release yes)
   (<n1> ^next <n2>)
   # t=2 add second task
   (<n2> ^add <a2>)
   (<a2> ^obj <input>
         ^task <t2>)
   (<t2> ^ID 1
         ^workload 4
         ^release yes)
   (<n2> ^next <n3>)
   # t=3 add third task
   (<n3> ^add <a3>)
   (<a3> ^obj <input>
         ^task <t3>)
   (<t3> ^ID 2
         ^workload 4
         ^release yes)
   (<n3> ^next <n4>)
}

# generalized rules
sp {apply*simulate-input*remove
   (state <s> #^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task.current <current>)
   (<o> ^name simulate-input)
   (<current> ^remove <removal>)
   (<removal> ^obj <obj>
              ^attribute <attr>
              ^value <val>)
-->
   (<obj> ^<attr> <val> -)
}
sp {apply*simulate-input*add
   (state <s> #^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task.current <current>)
   (<o> ^name simulate-input)
   (<current> ^add <addition>)
   (<addition> ^obj <obj>
               ^{<attr> <> obj} <val>)
-->
   (<obj> ^<attr> <val>)
}
sp {apply*simulate-input*add*task
   (state <s> #^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task.current <current>
              ^io.input-link <input>)
   (<o> ^name simulate-input)
   (<current> ^task <task>)
-->
   (<input> ^task <task>)
}
sp {apply*simulate-input*end
   (state <s> #^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulated yes
              ^simulate-task.current <current>)
   (<current> -^next <next>)
-->
   (write (crlf) |end|)
   (halt)
}
sp {x*finish*simulate*input
   (state <s> #^name scope
              ^phase simulate-input
              ^operator <o>
              ^simulate-task <sim>)
   (<sim> ^current <current>)
   (<current> ^next <next>)
   (<o> ^name simulate-input)
-->
   (<sim> ^current <current> -
        ^current <next>)
}